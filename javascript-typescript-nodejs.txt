JAVASCRIPT
==============================================================================
https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth
Agents
  JS engine "agents" execute JavaScript.
  Each agent has:
    - execution contexts
      - nodejs(?) use case: you can record the "entry-point" for a task in its
        execution context, then later retrieve it from any function on the same
        microtask callstack.
    - execution context stack
    - main thread
    - task queue
    - microtask queue
    - additional threads that may be created to handle workers
Event loops:
  - Window event loop
    - windows from the same origin MAY share the same event loop
      - If one window opened the other window, they are likely to share an event loop.
      - <iframe> window likely shares an event loop with its parent window.
    - "window" means "browser-level container that runs web content"
  - Worker event loop
    - workers MAY share a single event loop
  - Worklet event loop
Tasks vs microtasks
  task: any JavaScript scheduled by standard mechanisms, including setTimeout() and setInterval().
  The difference between the task queue and the microtask queue is simple but very important:
    - When executing tasks from the task queue, the runtime executes all tasks
      in the queue at the moment of the current tick. Tasks added during this
      iteration will not run until the *next* iteration.
    - Each time a TASK exits, and the execution context stack is empty, each
      MICROTASK in the microtask queue is executed, one after another. The
      difference is that execution of microtasks continues until the queue is
      empty, even if new ones are scheduled in the interim.
  queueMicrotask(callback)  https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask
    - what: queues a microtask to be executed before control returns to the browser event loop.
    - why: ability to perform tasks asynchronously but in a specific order.
    - when: useful for libraries and frameworks that need to perform final cleanup or other just-before-rendering tasks.
    - Almost as fast as a synchronous call (much more efficient than setTimeout(fn,0)).
    - potential infinite loop
    - potentially starves I/O
    - nodejs(?) Errors thrown within a queued microtask callback should be handled in the callback. Else use process.on('uncaughtException')

object vs Map:  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map

Function.prototype.bind(fn[, ...])  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind
                             ^ partial application!
  Creates a new function where `this` is set to the given value.
  Example:
    // NB: console.error() expects `this` to be `window.console`.
    foo(…).catch(console.error.bind(console, 'foo: '))

Proxy
  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy
    The Proxy object enables you to create a proxy for another object, which can
    intercept and redefine fundamental operations for that object.
  Observe/listen to field changes:
    private createReactive<T extends Record<string, any>>(obj: T): T {
      return new Proxy(obj, {
        set: (target, prop, val, recv) => {
          const last = Reflect.get(target, prop, recv)
          const success = Reflect.set(target, prop, val, recv)
          if (success && last !== val) {
            this.emitEvent()
          }
          return success
        }
      })
    }

Symbol
  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol
    Used to add unique property keys to an object, which are hidden from any mechanisms other code will typically use to access the object.
    Example:
      let object = {
          aNumber: 0,
          [Symbol.toPrimitive]() {  // cf. Object.prototype.valueOf
              return this.aNumber;
          }
      };
      object.aNumber = 5;
      console.log(object + 2)  // 7
    Symbol-keyed properties are completely ignored by JSON.stringify().

NODE.JS
==============================================================================
globals  https://nodejs.org/api/globals.html#globals_global
  global
  process
  require()

UNHANDLED PROMISE REJECTIONS, UNCAUGHT EXCEPTIONS
  https://medium.com/@nodejs/node-js-promise-reject-use-case-survey-98e3328340c9
  nodejs option: --unhandled-rejection=strict
  global handlers:
    process.on('unhandledRejection'))
    process.on('uncaughtException')
    Problem: any package/dependency can add its own handler!
    VSCode extension can't use? https://github.com/microsoft/vscode/issues/93573

setImmediate(), process.nextTick(), …  https://nodejs.org/api/process.html#process_process_nexttick_callback_args
  nextTick()
    DEPRECATED. Use queueMicrotask().  https://nodejs.org/api/process.html#when-to-use-queuemicrotask-vs-processnexttick
    queues a function BEFORE pending I/O callbacks
    Adds callback to the "next tick queue" (essentially the head of the event queue).
    Use case: to give users the opportunity to assign event handlers on object-construction but before I/O has occurred.
  setImmediate()
    DEPRECATED. Use queueMicrotask().  https://developer.mozilla.org/en-US/docs/Web/API/Window/setImmediate
    queues a function AFTER pending I/O callbacks
    yields to event loop after firing a queued callback to ensure I/O is not starved.
    Use case: to break up a long running CPU-bound job, use setImmediate rather than process.nextTick to queue the next iteration (otherwise any I/O event callbacks wouldn't get the chance to run between iterations).

event-loop phases  https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/
  timers:            execute callbacks scheduled by setTimeout()/setInterval().
  pending callbacks: execute I/O callbacks deferred to the next loop iteration.
  idle, prepare:     only used internally.
  poll:              gather new I/O events;
                     execute I/O callbacks (=> all callbacks except close callbacks, timer callbacks, and setImmediate());
                     node may block here.
  check:             execute setImmediate() callbacks.
  close callbacks:   some close callbacks, e.g. socket.on('close', …).

  > Between each run of the event-loop, Node.js checks if it is waiting for any
  > asynchronous I/O or timers and shuts down cleanly if there are not any.

known issue: "stdio buffered writes (chunked) issues & process.exit() truncation"
  https://github.com/nodejs/node/issues/6456
  workaround: https://www.npmjs.com/package/node-exit

TYPESCRIPT
==============================================================================
https://basarat.gitbook.io/typescript/type-system/freshness

Declare a motherfucking map:
  const things: { [key: string]: boolean } = {}

https://httptoolkit.tech/blog/5-big-features-of-typescript-3.7/

type transformations/composition
  https://www.typescriptlang.org/docs/handbook/utility-types.html

optional chaining x
  // With TS 3.7:
  // Returns the value is it's all defined & non-null, or undefined if not.
  let result = data?.key1?.key2;
  // The same, through an array index or property, if possible:
  array?.[0]?.['key'];
  // Call a method, but only if it's defined:
  obj.method?.();
  // Get a property, or return 'default' if any step is not defined:
  let result = data?.key1?.key2 ?? 'default';
  // GOTCHA: returns undefined for missing values, even if they were null.
  (null)?.key  // returns undefined

NPM
==============================================================================
webpack will use whatever is in node_modules regardless of where it came from.
Once bundled, it doesn't matter whether a dep was declared in package.json
"dependencies" or "devDependencies". dev-deps only matter when others consume
the package as a dependency.
